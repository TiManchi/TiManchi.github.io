<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Wang Yiran - 今日事,今日毕</title><meta name="author" content="Wang Yiran"><meta name="copyright" content="Wang Yiran"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="website">
<meta property="og:title" content="Wang Yiran">
<meta property="og:url" content="https://timanchi.github.io/index.html">
<meta property="og:site_name" content="Wang Yiran">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wyr-image.oss-cn-beijing.aliyuncs.com/img/bd5e70c725673e6eeca43c65ed22eade.jpeg">
<meta property="article:author" content="Wang Yiran">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wyr-image.oss-cn-beijing.aliyuncs.com/img/bd5e70c725673e6eeca43c65ed22eade.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://timanchi.github.io/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Wang Yiran',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2022-08-06 14:30:41'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://wyr-image.oss-cn-beijing.aliyuncs.com/img/bd5e70c725673e6eeca43c65ed22eade.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url('https://wyr-image.oss-cn-beijing.aliyuncs.com/img/wallhaven-rddgwm_1920x1080.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Wang Yiran</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">Wang Yiran</h1><div id="site-subtitle"><span id="subtitle"></span></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="post_cover left"><a href="/2022/04/08/%E6%A0%88%E7%9A%84%E5%B8%B8%E8%A7%81%E9%A2%98%E5%9E%8B/" title="栈的常见题型"><img class="post_bg" src="https://images.weserv.nl/?url=https://article.biliimg.com/bfs/article/554584218db9279874e48559f9a8e86b9ecca94b.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="栈的常见题型"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/04/08/%E6%A0%88%E7%9A%84%E5%B8%B8%E8%A7%81%E9%A2%98%E5%9E%8B/" title="栈的常见题型">栈的常见题型</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-04-07T16:00:00.000Z" title="发表于 2022-04-08 00:00:00">2022-04-08</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%A0%88/">栈</a></span></div><div class="content">介绍我们此处说的栈，是数据结构中的栈，而不是指系统层面的，系统层面说的栈区（ stack ），是指由编译器自动分配释放，存放函数的参数值，局部变量的值等区域。数据结构里面的栈是限定仅在表尾进行插入或者删除的线性表，所谓的表尾，其实就是我们所称的栈顶，相应的，我们可以称表头为栈底。栈的最重要的特性，是后进先出（Last in first out），也称为 LIFO 结构。
使用两个栈实现队列解题思路栈结构的特性是先进后出，而队列的特性是先进先出，也就是先进来的数据先出去，就像是水管一样，前面的水先流出来。
但是假如我们不想直接使用队列，想用栈实现队列，至少需求多少个栈可以实现一个队列呢？答案是两个，为什么呢？
因为栈本身是先进后出的，假设我们需要先进先出，那么势必需要另外一个堆栈保存数据。数据进入一个堆栈，出来时是逆序的，但是数据依次进入两个堆栈，出来是正序的。
有两个栈 stack1 和 stack2，如果有新的数据进入，那么我们可以直接 push 到 stack1 中。
如果需要取出数据，那么我们优先取出 stack2 的数据，如果 stack2 里面的数据是空的，那么我们需要把 s ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2022/03/29/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E8%A7%81%E9%A2%98%E5%9E%8B/" title="字符串常见题型"><img class="post_bg" src="https://images.weserv.nl/?url=https://article.biliimg.com/bfs/article/554584218db9279874e48559f9a8e86b9ecca94b.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="字符串常见题型"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/03/29/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E8%A7%81%E9%A2%98%E5%9E%8B/" title="字符串常见题型">字符串常见题型</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-03-28T16:00:00.000Z" title="发表于 2022-03-29 00:00:00">2022-03-29</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/">字符串</a></span></div><div class="content">翻转句子里的单词问题描述现在有一个小任务，假设有一个字符串 “I love coding”，要求将里面单词的顺序翻转，但是单词内部的字母顺序不变，也就是翻转之后结果为 “coding love I“。
求解思路
将字符串分割成若干个子串。

利用中心对称，将字符串转换成为倒序的。

遍历子串，去掉多余的空格，每个有效的子串后面增加一个空格。

去掉结果最后多余的空格。


代码实现const reverseWords = s =&gt; &#123;    const arr = s.split(&#x27; &#x27;);    const res = [];    for (let i = arr.length - 1; i &gt;= 0; i--) &#123;        arr[i] &amp;&amp; res.push(arr[i]);    &#125;    return res.join(&#x27; &#x27;);&#125;;

寻找最长回文子串问题描述“上海自来水来自海上”，这句话不管是顺着读还是逆着读，都是一样的，这就是回文串。给出一个字符串 s，找 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2022/03/28/%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%B8%B8%E8%A7%81%E9%A2%98%E5%9E%8B/" title="数组和链表的常见题型"><img class="post_bg" src="https://images.weserv.nl/?url=https://article.biliimg.com/bfs/article/554584218db9279874e48559f9a8e86b9ecca94b.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数组和链表的常见题型"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/03/28/%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%B8%B8%E8%A7%81%E9%A2%98%E5%9E%8B/" title="数组和链表的常见题型">数组和链表的常见题型</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-03-27T16:00:00.000Z" title="发表于 2022-03-28 00:00:00">2022-03-28</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%95%B0%E7%BB%84/">数组</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E9%93%BE%E8%A1%A8/">链表</a></span></div><div class="content">数组在计算机中是以连续空间的形态存在，而链表则是不要求空间连续，每一个元素都保存着下一个元素的地址，使其更加灵活。
约瑟夫环问题问题描述著名的约瑟夫问题：编号为 1-N 的 N 个士兵围坐在一起形成一个圆圈，从编号为 1 的士兵开始依次报数（1，2，3… 这样依次报数），数到 m 的 士兵会被淘汰出列，之后的士兵再从 1 开始报数。直到最后剩下一个士兵，求这个士兵的编号。
求解思路假设我们现在需要使用数组解决该问题，用一个数组存在 1，2，3，4，5 … 编号，要求返回最后一个士兵的编号。思路如下

初始化剩下的士兵人数 retainNum 为 n，循环下面的操作，直到全部士兵出圈。
初始化 k = 0，从第一个士兵开始计数，每次遍历到数值不为 -1 的元素，则 k+1，如果 k = M，则说明该士兵需要被淘汰出局，则元素的值置为 -1，淘汰的数量 num + 1，且 k 重新赋值为 0。
遍历数组元素，找到数值不为 -1 的元素，就是最后剩下的士兵。

假设 5 个士兵，数到 3 就淘汰，具体的执行过程如下：

代码实现如下：/** * @param &#123;number&#12 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2021/07/10/R-CNN/" title="R-CNN"><img class="post_bg" src="https://images.weserv.nl/?url=https://article.biliimg.com/bfs/article/554584218db9279874e48559f9a8e86b9ecca94b.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="R-CNN"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/07/10/R-CNN/" title="R-CNN">R-CNN</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-07-09T16:00:00.000Z" title="发表于 2021-07-10 00:00:00">2021-07-10</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AC%94%E8%AE%B0/">目标检测笔记</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/">目标检测</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/">计算机视觉</a></span></div><div class="content">R-CNN（Rich feature hierarchies for accurate object detection and semantic segmentation）是最早将深度学习应用于目标检测领域的方法之一，其使用基于候选区域的方法替代滑动窗口来寻找图像中可能存在目标的区域，使用卷积神经网络替代人工设计的特征用于目标特征的提取，然后使用支持向量机（SVM）判断目标类别并使用边框回归（Bounding-Box Regression）修正候选框（Bounding Box）的位置。相较于传统的方法，R-CNN 提高了检测的准确率和面对复杂环境的鲁棒性。
如下图，R-CNN 可以分为以下四个步骤。

使用候选区域方法找出图片中可能存在目标的区域。
将这些区域缩放成相同尺寸输入卷积神经网络，通过网络提取每个区域的特征。
将提取到的特征输入分类器并判别每个特征所属类别。
使用边框回归修正候选框的位置。


</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2021/06/27/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" title="卷积神经网络"><img class="post_bg" src="https://images.weserv.nl/?url=https://article.biliimg.com/bfs/article/554584218db9279874e48559f9a8e86b9ecca94b.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="卷积神经网络"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/06/27/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" title="卷积神经网络">卷积神经网络</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-06-26T16:00:00.000Z" title="发表于 2021-06-27 00:00:00">2021-06-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AC%94%E8%AE%B0/">目标检测笔记</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/">目标检测</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/">计算机视觉</a></span></div><div class="content">介绍在之前的文章中，我们了解到神经网络的输入层中的每个节点都与下一层的每个节点相连接，我们称这种连接方式为全连接（Fully-connected），但是这种全连接方式存在一些明显的缺陷。首先如果使用全连接网络处理图片的话，需要将图像矩阵转换为一列向量，这样就破坏了图像的空间信息。其次假设我们将一张尺寸为 $240\times240\times3$ 的三通道图片作为全连接网络的输入，则在输入层总共需要 172800个权重，如此多的参数需要很大的计算量和时间处理，并且大量的参数还会导致过拟合（模型在训练集上表现好，在测试集上表现差，泛化能力差）。在计算机视觉中广泛应用的卷积神经网络可以用来克服上述问题，在卷积神经网络中我们采取局部连接节点的方式代替全连接的方式，通常一个卷积神经网络由输入层、卷积层，激活层、池化层和全连接层构成。
卷积和卷积核在开始学习卷积神经网络前，我们需要了解卷积和卷积核（Kernel）的相关内容。通常情况下，深度学习中所谓的卷积实际上是互相关操作（在后面的内容中我将用卷积来称呼互相关操作），如下图，两个矩阵的卷积即是将两个矩阵中对应位置的元素相乘再求和，则这两个矩阵的 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2021/06/21/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" title="非极大值抑制"><img class="post_bg" src="https://images.weserv.nl/?url=https://article.biliimg.com/bfs/article/554584218db9279874e48559f9a8e86b9ecca94b.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="非极大值抑制"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/06/21/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" title="非极大值抑制">非极大值抑制</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-06-20T16:00:00.000Z" title="发表于 2021-06-21 00:00:00">2021-06-21</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AC%94%E8%AE%B0/">目标检测笔记</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/">目标检测</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/">计算机视觉</a></span></div><div class="content">人工神经网络传统的算法需要花费大量时间人为的设计特征，在实际应用中面对复杂的背景和目标时往往表现得并不理想。但是随着深度学习的崛起目标检测的性能和表现得到了大幅度的提升，深度学习的发展推动了目标检测的迅猛发展。
深度学习是人工智能的一个分支，其受人脑的结构和功能的启发，通过人工神经网络（Artificial Neural Network）模仿人脑处理数据和决策的方式从数据中学习内在规律和特征表示。随着近年的计算机性能的发展和海量数据的增长使得深度学习成为机器学习中的热门研究方向。如今深度学习已经广泛应用于我们的日常生活中，如在线翻译、人脸识别、语音转换等。
人工神经网络（Artificial Neural Network）是一类可以从提供的数据中学习的机器学习算法，是一种模仿人脑神经系统处理信息的运算模型，其由大量的节点或称为神经元相互连接构成。一个节点由输入（Input)、权重（Weight)、偏差（Bias）、激活函数（Activation Function）、输出（Output）组成。下图左边的图片是一个简单的三层神经网络，其中每一个圆形表示一个节点且每一个节点都与下一层中的每个 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2021/06/15/%E9%9D%9E%E6%9E%81%E5%A4%A7%E5%80%BC%E6%8A%91%E5%88%B6/" title="非极大值抑制"><img class="post_bg" src="https://images.weserv.nl/?url=https://article.biliimg.com/bfs/article/554584218db9279874e48559f9a8e86b9ecca94b.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="非极大值抑制"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/06/15/%E9%9D%9E%E6%9E%81%E5%A4%A7%E5%80%BC%E6%8A%91%E5%88%B6/" title="非极大值抑制">非极大值抑制</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-06-14T16:00:00.000Z" title="发表于 2021-06-15 00:00:00">2021-06-15</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AC%94%E8%AE%B0/">目标检测笔记</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/">目标检测</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/">计算机视觉</a></span></div><div class="content">非极大值抑制的作用在进行目标检测过程中，我们的分类器会对每一个滑动窗口的内容进行分类，而滑动窗口是按照设定的步长在图像金字塔的每个图层中从上到下、从左向右移动，这样一个目标就会出现在多个滑动窗口中，最后我们就会获得多个相交、重叠的矩形框。如下图在目标检测过程中目标上会产生多个矩形框，我们希望从这些矩形框中挑选出一个最合适的矩形框且剔除多余的矩形框，使得每个目标只被一个矩形框标记。

非极大值抑制（Non Maximum Suppression）以下简称 NMS，的主要作用是去除目标检测过程中产生的冗余矩形框。要实现 NMS 首先需要计算矩形框之间的交并比（Intersection over Union），以下简称 IoU。下图以直观的例子展示计算 IoU 的方法，左图中的目标（人）同时被两个矩形框标记，为了剔除多余的矩形框需要计算两个矩形框的 IoU。IoU 的计算的方法如下图中间的公式所示，即两个框的交集（红色区域）与两个框的并集（绿色区域）的比值。如果计算后的 IoU 大于事先设定的阈值，则剔除较小的矩形框（下图中最右边图片所示），通过这个过程我们就达到了剔除冗余的矩形框的目的。接 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2021/06/12/%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/" title="图像分类的基本知识"><img class="post_bg" src="https://images.weserv.nl/?url=https://article.biliimg.com/bfs/article/554584218db9279874e48559f9a8e86b9ecca94b.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="图像分类的基本知识"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/06/12/%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/" title="图像分类的基本知识">图像分类的基本知识</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-06-11T16:00:00.000Z" title="发表于 2021-06-12 00:00:00">2021-06-12</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AC%94%E8%AE%B0/">目标检测笔记</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/">目标检测</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/">计算机视觉</a></span></div><div class="content">介绍之前已经学会了如何使用图像金字塔和滑动窗口在图片中寻找目标，以及通过方向梯度直方图的方法对图像进行特征描述，但是光靠这些方法还不足以实现一个目标检测项目。对一张图片进行目标检测还需要判断滑动窗口寻找的物体是否是想要检测到，这就涉及到图像分类问题。
计算机视觉中的图像分类，简单来说就是为一张图片赋予一个标签（Label），一个标签就是人为定义的集合中的一个元素，例如下面公式表示我们定义了一个集合 $D$，$cat$ 、$dog$ 则被称为集合 $D$ 的 2 个不同标签。
$$ D &#x3D; {cat,\ dog} $$
以下图为例，图像分类任务就是希望给计算机提供左边的图片，则计算机将赋予其 $cat$ 标签，提供右边的图片，则赋予其 $dog$ 标签。在计算机视觉中我们希望构建一个系统，当给系统输入一张图片时，系统会分析该图片然后输出一系列标签的概率值（例如 $cat &#x3D; 0.89$，$dog &#x3D; 0.1$），而这些标签属于我们事先定义的一个类别集合（例如 $cat$ 和 $dog$ 属于集合 $D$）。更具体的来说假设我们有一张宽和高分别为 $W,\ H ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2021/06/11/%E6%96%B9%E5%90%91%E6%A2%AF%E5%BA%A6%E7%9B%B4%E6%96%B9%E5%9B%BE/" title="方向梯度直方图"><img class="post_bg" src="https://images.weserv.nl/?url=https://article.biliimg.com/bfs/article/554584218db9279874e48559f9a8e86b9ecca94b.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="方向梯度直方图"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/06/11/%E6%96%B9%E5%90%91%E6%A2%AF%E5%BA%A6%E7%9B%B4%E6%96%B9%E5%9B%BE/" title="方向梯度直方图">方向梯度直方图</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-06-10T16:00:00.000Z" title="发表于 2021-06-11 00:00:00">2021-06-11</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AC%94%E8%AE%B0/">目标检测笔记</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/">目标检测</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/">计算机视觉</a></span></div><div class="content">介绍传统的目标检测流程可分为三个步骤，第一步是使用滑动窗口和图像金字塔从图片中选择一些区域。第二步是将选择出来的区域转化为人工设计的特征，可称为特征提取。第三步是将这些特征输入分类器进行分类。方向梯度直方图（Histogram of Oriented Gradients）以下简称 HOG，就是一种人工设计的特征，用来简化图像表述的特征描述符。
下图中左边的图片是一只猫，我们不仅可以看出猫身体上的特征、颜色、纹理，而且还能看到背景。右边的图片是使用 HOG 来表示的图片，除了可以看到图中能看出猫的外形，其他的细节包括背景几乎都被去除了，故右边的图片是左边图片的一种简化表示形式。HOG 可以用来表示物体的形状、外形特征，将这些特征输入分类器就可以实现目标的分类。

方向梯度直方图流程预先归一化（Normalization）在计算梯度前可对图片归一化（Normalization）处理，归一化的目的是使所有的数值落入到统一的范围内，从而使算法能有更好的表现。
计算梯度前面提到可以不用预先对图片进行归一化，故可以说 HOG 特征是从计算图像在水平方向和垂直方向上的梯度开始的。图像的梯度计算是使用 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2021/06/08/%E5%9B%BE%E5%83%8F%E9%87%91%E5%AD%97%E5%A1%94/" title="图像金字塔"><img class="post_bg" src="https://images.weserv.nl/?url=https://article.biliimg.com/bfs/article/554584218db9279874e48559f9a8e86b9ecca94b.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="图像金字塔"></a></div><div class="recent-post-info"><a class="article-title" href="/2021/06/08/%E5%9B%BE%E5%83%8F%E9%87%91%E5%AD%97%E5%A1%94/" title="图像金字塔">图像金字塔</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2021-06-07T16:00:00.000Z" title="发表于 2021-06-08 00:00:00">2021-06-08</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AC%94%E8%AE%B0/">目标检测笔记</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/">目标检测</a><span class="article-meta-link">•</span><a class="article-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/">计算机视觉</a></span></div><div class="content">图像金字塔的作用图像金字塔简单来说就是用多个不同的尺寸来表示一张图片。如下图，最左边的图片是原始图片，然后从左向右图片的尺寸依次缩小直到图片的尺寸达到一个阈值，这个阈值就是多次缩小图片的最小尺寸，不会有比这更小尺寸的图片了，像这种图片的尺寸逐步递增或递减的多张图层就是图像金字塔，每张不同尺寸的图片都称为图像金字塔的一层。图像金字塔的目的就是寻找图片中出现的不同尺寸的目标（物体、动物等）。

代码实现创建了、一个名为 pyramid 函数，这个函数将用来生成图像金字塔，这个函数有三个参数，如下所示。

第一个参数 image 是要进行图像金字塔操作的原始图片。
第二个参数 top 是图像将会被缩小的最小尺寸，我们将这个参数设置一个默认值为 (128, 128)，第一个 128 表示图片的高，第二个 128 表示图片的宽。
第三个参数 ratio 表示每次图像将会被缩小 ratio 倍，我们给这个参数设置了一个默认值为 1.2。

import cv2from matplotlib import pyplot as pltfrom IPython import display%matplo ...</div></div></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/#content-inner">2</a><a class="extend next" rel="next" href="/page/2/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://wyr-image.oss-cn-beijing.aliyuncs.com/img/bd5e70c725673e6eeca43c65ed22eade.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Wang Yiran</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/04/08/%E6%A0%88%E7%9A%84%E5%B8%B8%E8%A7%81%E9%A2%98%E5%9E%8B/" title="栈的常见题型"><img src="https://images.weserv.nl/?url=https://article.biliimg.com/bfs/article/554584218db9279874e48559f9a8e86b9ecca94b.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="栈的常见题型"/></a><div class="content"><a class="title" href="/2022/04/08/%E6%A0%88%E7%9A%84%E5%B8%B8%E8%A7%81%E9%A2%98%E5%9E%8B/" title="栈的常见题型">栈的常见题型</a><time datetime="2022-04-07T16:00:00.000Z" title="发表于 2022-04-08 00:00:00">2022-04-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/29/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E8%A7%81%E9%A2%98%E5%9E%8B/" title="字符串常见题型"><img src="https://images.weserv.nl/?url=https://article.biliimg.com/bfs/article/554584218db9279874e48559f9a8e86b9ecca94b.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="字符串常见题型"/></a><div class="content"><a class="title" href="/2022/03/29/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E8%A7%81%E9%A2%98%E5%9E%8B/" title="字符串常见题型">字符串常见题型</a><time datetime="2022-03-28T16:00:00.000Z" title="发表于 2022-03-29 00:00:00">2022-03-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/28/%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%B8%B8%E8%A7%81%E9%A2%98%E5%9E%8B/" title="数组和链表的常见题型"><img src="https://images.weserv.nl/?url=https://article.biliimg.com/bfs/article/554584218db9279874e48559f9a8e86b9ecca94b.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数组和链表的常见题型"/></a><div class="content"><a class="title" href="/2022/03/28/%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%B8%B8%E8%A7%81%E9%A2%98%E5%9E%8B/" title="数组和链表的常见题型">数组和链表的常见题型</a><time datetime="2022-03-27T16:00:00.000Z" title="发表于 2022-03-28 00:00:00">2022-03-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/10/R-CNN/" title="R-CNN"><img src="https://images.weserv.nl/?url=https://article.biliimg.com/bfs/article/554584218db9279874e48559f9a8e86b9ecca94b.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="R-CNN"/></a><div class="content"><a class="title" href="/2021/07/10/R-CNN/" title="R-CNN">R-CNN</a><time datetime="2021-07-09T16:00:00.000Z" title="发表于 2021-07-10 00:00:00">2021-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/06/27/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" title="卷积神经网络"><img src="https://images.weserv.nl/?url=https://article.biliimg.com/bfs/article/554584218db9279874e48559f9a8e86b9ecca94b.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="卷积神经网络"/></a><div class="content"><a class="title" href="/2021/06/27/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" title="卷积神经网络">卷积神经网络</a><time datetime="2021-06-26T16:00:00.000Z" title="发表于 2021-06-27 00:00:00">2021-06-27</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><span class="card-category-list-name">数据结构与算法</span><span class="card-category-list-count">3</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%AC%94%E8%AE%B0/"><span class="card-category-list-name">目标检测笔记</span><span class="card-category-list-count">8</span></a></li>
            </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size: 1.1em; color: #999">字符串</a> <a href="/tags/%E6%95%B0%E7%BB%84/" style="font-size: 1.1em; color: #999">数组</a> <a href="/tags/%E6%A0%88/" style="font-size: 1.1em; color: #999">栈</a> <a href="/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/" style="font-size: 1.5em; color: #99a9bf">目标检测</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/" style="font-size: 1.5em; color: #99a9bf">计算机视觉</a> <a href="/tags/%E9%93%BE%E8%A1%A8/" style="font-size: 1.1em; color: #999">链表</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/04/"><span class="card-archive-list-date">四月 2022</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/03/"><span class="card-archive-list-date">三月 2022</span><span class="card-archive-list-count">2</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/07/"><span class="card-archive-list-date">七月 2021</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/06/"><span class="card-archive-list-date">六月 2021</span><span class="card-archive-list-count">6</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/05/"><span class="card-archive-list-date">五月 2021</span><span class="card-archive-list-count">1</span></a></li></ul></div></div></div></main><footer id="footer" style="background-image: url('https://wyr-image.oss-cn-beijing.aliyuncs.com/img/wallhaven-rddgwm_1920x1080.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Wang Yiran</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function subtitleType () {
  if (true) { 
    window.typed = new Typed("#subtitle", {
      strings: ["今日事,今日毕"],
      startDelay: 300,
      typeSpeed: 150,
      loop: true,
      backSpeed: 50
    })
  } else {
    document.getElementById("subtitle").innerHTML = '今日事,今日毕'
  }
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.jsdelivr.net/npm/typed.js/lib/typed.min.js').then(subtitleType)
  }
} else {
  subtitleType()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>